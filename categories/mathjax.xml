<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>KK's Blog (Posts about mathjax)</title><link>https://bebound.github.io/</link><description></description><atom:link href="https://bebound.github.io/categories/mathjax.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2018 &lt;a href="mailto:bebound gm@il.com"&gt;Kurt Lei&lt;/a&gt; </copyright><lastBuildDate>Sun, 18 Nov 2018 07:44:07 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>LSTM and GRU</title><link>https://bebound.github.io/posts/lstm-and-gru/</link><dc:creator>Kurt Lei</dc:creator><description>&lt;div&gt;&lt;h3&gt;LSTM&lt;/h3&gt;
&lt;p&gt;The avoid the problem of vanishing gradient and exploding gradient in vanilla RNN, LSTM was published, which can remember information for longer periods of time.&lt;/p&gt;
&lt;p&gt;Here is the structure of LSTM:&lt;/p&gt;
&lt;p&gt;&lt;img alt="LSTM" src="https://bebound.github.io/images/LSTM_LSTM.png"&gt;&lt;/p&gt;
&lt;p&gt;The calculate procedure are:&lt;/p&gt;
&lt;div&gt;

$$
\begin{aligned}
f_t&amp;amp;=\sigma(W_f\cdot[h_{t-1},x_t]+b_f)\\
i_t&amp;amp;=\sigma(W_i\cdot[h_{t-1},x_t]+b_i)\\
o_t&amp;amp;=\sigma(W_o\cdot[h_{t-1},x_t]+b_o)\\
\tilde{C_t}&amp;amp;=tanh(W_C\cdot[h_{t-1},x_t]+b_C)\\
C_t&amp;amp;=f_t\ast C_{t-1}+i_t\ast \tilde{C_t}\\
h_t&amp;amp;=o_t \ast tanh(C_t)
\end{aligned}
$$

&lt;/div&gt;

&lt;p&gt;$f_t$,$i_t$,$o_t$ are forget gate, input gate and output gate respectively. $\tilde{C_t}$ is the new memory content. $C_t$ is cell state. $h_t$ is the output. &lt;/p&gt;
&lt;p&gt;Use $f_t$ and $i_t$ to update $C_t$, use $o_t$ to decide which part of hidden state should be outputted.&lt;/p&gt;
&lt;h3&gt;GRU&lt;/h3&gt;
&lt;p&gt;&lt;img alt="LSTM" src="https://bebound.github.io/images/LSTM_GRU.png"&gt;&lt;/p&gt;
&lt;div&gt;

$$
\begin{aligned}
z_t&amp;amp;=\sigma(W_z\cdot[h_{t-1},x_t])\\
r_t&amp;amp;=\sigma(W_r\cdot[h_{t-1},x_t])\\
\tilde{h_t}&amp;amp;=tanh(W\cdot[r_t \ast h_{t-1},x_t])\\
h_t&amp;amp;=(1-z_t)\ast h_{t-1}+z_t \ast \tilde{h_t}
\end{aligned}
$$

&lt;/div&gt;

&lt;p&gt;$z_t$ is update gate, $r_t$ is reset gate, $\tilde{h_t}$ is candidate activation, $h_t$ is activation.&lt;/p&gt;
&lt;p&gt;Compare with LSTM, GRU merge cell state and hidden state to one hiddent state, and use $z_t$ to decide how to update the state rather than $f_t$ and $i_t$.&lt;/p&gt;
&lt;p&gt;Update:&lt;/p&gt;
&lt;p&gt;Here is a good article: &lt;a href="https://medium.com/m/global-identity?redirectUrl=https%3A%2F%2Ftowardsdatascience.com%2Fillustrated-guide-to-lstms-and-gru-s-a-step-by-step-explanation-44e9eb85bf21"&gt;Illustrated Guide to LSTM’s and GRU’s: A step by step explanation&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Ref：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://colah.github.io/posts/2015-08-Understanding-LSTMs/"&gt;Understanding LSTM Networks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.csdn.net/zhangxb35/article/details/70060295"&gt;RNN, LSTM, GRU 公式总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</description><category>mathjax</category><guid>https://bebound.github.io/posts/lstm-and-gru/</guid><pubDate>Sun, 22 Apr 2018 15:27:45 GMT</pubDate></item><item><title>Models and Architechtures in Word2vec</title><link>https://bebound.github.io/posts/models-and-architechtures-in-word2vec/</link><dc:creator>Kurt Lei</dc:creator><description>&lt;div&gt;&lt;h3&gt;Models&lt;/h3&gt;
&lt;h4&gt;CBOW (Continuous Bag of Words)&lt;/h4&gt;
&lt;p&gt;Use the context to predict the probability of current word.&lt;/p&gt;
&lt;p&gt;&lt;img alt="cbow" src="https://bebound.github.io/images/doc2vec_cbow.png"&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Context words' vectors are $\upsilon_{c-n} ... \upsilon_{c+m}$ ($m$ is the window size)&lt;/li&gt;
&lt;li&gt;Context vector $ \hat{\upsilon}=\frac{\upsilon_{c-m}+\upsilon_{c-m+1}+...+\upsilon_{c+m}}{2m} $&lt;/li&gt;
&lt;li&gt;Score vector $z_i = u_i\hat{\upsilon}$, where $u_i$ is the output vector representation of word $\omega_i$&lt;/li&gt;
&lt;li&gt;Turn scores into probabilities $\hat{y}=softmax(z)$&lt;/li&gt;
&lt;li&gt;We desire probabilities $\hat{y}$ match the true probabilities $y$.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We use cross entropy $H(\hat{y},y)$ to measure the distance between these two distributions.
$$H(\hat{y},y)=-\sum_{j=1}^{\lvert V \rvert}{y_j\log(\hat{y}_j)}$$&lt;/p&gt;
&lt;p&gt;$y$ and $\hat{y}$ is accurate, so the loss simplifies to:
$$H(\hat{y},y)=-y_j\log(\hat{y})$$&lt;/p&gt;
&lt;p&gt;For perfect prediction, $H(\hat{y},y)=-1\log(1)=0$&lt;/p&gt;
&lt;p&gt;According to this, we can create this loss function:&lt;/p&gt;
&lt;div&gt;

$$\begin{aligned}
minimize\ J &amp;amp;=-\log P(\omega_c\lvert \omega_{c-m},...,\omega_{c-1},...,\omega_{c+m}) \\
&amp;amp;= -\log P(u_c \lvert \hat{\upsilon}) \\
&amp;amp;= -\log \frac{\exp(u_c^T\hat{\upsilon})}{\sum_{j=1}^{\lvert V \rvert}\exp (u_j^T\hat{\upsilon})} \\
&amp;amp;= -u_c^T\hat{\upsilon}+\log \sum_{j=1}^{\lvert V \rvert}\exp (u_j^T\hat{\upsilon})
\end{aligned}$$

&lt;/div&gt;

&lt;h4&gt;Skip-Gram&lt;/h4&gt;
&lt;p&gt;Use current word to predict its context.&lt;/p&gt;
&lt;p&gt;&lt;img alt="cbow" src="https://bebound.github.io/images/doc2vec_skip-gram.png"&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;We get the input word's vector $\upsilon_c$&lt;/li&gt;
&lt;li&gt;Generate $2m$ score vectors, $uc_{c-m},...,u_{c-1},...,u_{c+m}$.&lt;/li&gt;
&lt;li&gt;Turn scores into probabilities $\hat{y}=softmax(u)$&lt;/li&gt;
&lt;li&gt;We desire probabilities $\hat{y}$ match the true probabilities $y$.&lt;/li&gt;
&lt;/ol&gt;
&lt;div&gt;

$$\begin{aligned}
minimize J &amp;amp;=-\log P(\omega_{c-m},...,\omega_{c-1},\omega_{c+1},...\omega_{c+m}\lvert \omega_c)\\
&amp;amp;=-\log \prod_{j=0,j\ne m}^{2m}P(\omega_{c-m+j}\lvert \omega_c)\\
&amp;amp;=-\log \prod_{j=0,j\ne m}^{2m}P(u_{c-m+j}\lvert \upsilon_c)\\
&amp;amp;=-\log \prod_{j=0,j\ne m}^{2m}\frac{\exp (u^T_{c-m+j}\upsilon_c)}{\sum_{k=1}^{\lvert V \rvert}{\exp (u^T_k \upsilon_c)}}\\
&amp;amp;=-\sum_{j=0,j\ne m}^{2m}{u^T_{c-m+j}\upsilon_c+2m\log \sum_{k=1}^{\lvert V \rvert} \exp(u^T_k \upsilon_c)}
\end{aligned}$$

&lt;/div&gt;

&lt;h3&gt;Models&lt;/h3&gt;
&lt;p&gt;Minimize $J$ is expensive, as the summation is over $\lvert V \rvert$. There are two ways to reduce the computation. Hierarchical Softmax and Negative Sampling.&lt;/p&gt;
&lt;h4&gt;Hierarchical Softmax&lt;/h4&gt;
&lt;p&gt;Encode words into a huffman tree, then each word has a Huffman code. The probability of it's probability $P(w\lvert Context(\omega))$ can change to choose the right path from root the che leaf node, each node is a binary classification. Suppose code $0$ is a possitive label, $1$ is negative label. If the probability of a possitive classification is 
$$
\sigma(X^T_\omega \theta)=\frac{1}{1+e^{-X^T_\omega}}
$$&lt;/p&gt;
&lt;p&gt;Then the probability of negative classification is
$$
1-\sigma(X^T_\omega \theta)
$$&lt;/p&gt;
&lt;p&gt;&lt;img alt="cbow" src="https://bebound.github.io/images/doc2vec_hierarchical_softmax.png"&gt;
足球's Huffman code is $1001$, then it's probability in each node are&lt;/p&gt;
&lt;div&gt;

$$\begin{aligned}
p(d_2^\omega\lvert X_\omega,\theta^\omega_1&amp;amp;=1-\sigma(X^T_\omega \theta^\omega_1))\\
p(d^\omega_3\lvert X_\omega,\theta^\omega_2&amp;amp;=\sigma(X^T_\omega \theta^\omega_2))\\
p(d^\omega_4\lvert X_\omega,\theta^\omega_3&amp;amp;=\sigma(X^T_\omega \theta^\omega_3))\\
p(d^\omega_5\lvert X_\omega,\theta^\omega_4&amp;amp;=1-\sigma(X^T_\omega \theta^\omega_4))\\
\end{aligned}$$

&lt;/div&gt;

&lt;p&gt;where $\theta$ is prarameter in the node.&lt;/p&gt;
&lt;p&gt;The probability of the &lt;code&gt;足球&lt;/code&gt; is the production of these equation.&lt;/p&gt;
&lt;p&gt;Generally,&lt;/p&gt;
&lt;div&gt;

$$p(\omega\lvert Context(\omega))=\prod_{j=2}^{l\omega}p(d^\omega_j\lvert X_\omega,\theta^\omega_{j-1})$$

&lt;/div&gt;

&lt;h4&gt;Negative Sampling&lt;/h4&gt;
&lt;p&gt;Choose some negitive sample, add the probability of the negative word into loss function. Maximize the positive words' probability and minimize the negitive words' probability.&lt;/p&gt;
&lt;p&gt;Let $P(D=0 \lvert \omega,c)$ be the probability that $(\omega,c)$ did not come from the corpus data. Then the objective funtion will be&lt;/p&gt;
&lt;div&gt;

$$\theta = \text{argmax} \prod_{(\omega,c)\in D} P(D=1\lvert \omega,c,\theta) \prod_{(\omega,c)\in \tilde{D}} P(D=0\lvert \omega,c,\theta)$$

&lt;/div&gt;

&lt;p&gt;where $\theta$ is the parameters of the model($\upsilon$ and $u$).&lt;/p&gt;
&lt;p&gt;Ref:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.hankcs.com/nlp/word2vec.html"&gt;word2vec原理推导与代码分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://cs224d.stanford.edu/lecture_notes/notes1.pdf"&gt;CS 224D: Deep Learning for NLP Lecture Notes: Part I&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.csdn.net/itplus/article/details/37969519"&gt;word2vec 中的数学原理详解（一）目录和前言&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</description><category>mathjax</category><category>word2vec</category><guid>https://bebound.github.io/posts/models-and-architechtures-in-word2vec/</guid><pubDate>Fri, 05 Jan 2018 13:57:17 GMT</pubDate></item><item><title>Semi-supervised text classification using doc2vec and label spreading</title><link>https://bebound.github.io/posts/semi-supervised-text-classification-using-doc2vec-and-label-spreading/</link><dc:creator>Kurt Lei</dc:creator><description>&lt;div&gt;&lt;p&gt;Here is a simple way to classify text without much human effort and get a impressive performance.&lt;/p&gt;
&lt;p&gt;It can be divided into two steps:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Get train data by using keyword classificaton&lt;/li&gt;
&lt;li&gt;Generate a more accurate classification model by using doc2vec and label spreading&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;Keyword-based Classification&lt;/h4&gt;
&lt;p&gt;Keyword based classification is a simple but effective method. Extracting the target keyword is a monotonous work. I use this method to automatic extract keyword candicate.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Find some most common words to classify the text.&lt;/li&gt;
&lt;li&gt;Use this equition to calculate the score of each word appears in the text.
   $$ score(i) = \frac{count(i)}{all\_count(i)^{0.3}}$$
   which $all\_count(i)$ is the word i's wordc ount in all corpus, and $count(i)$ is the word i's word count in positive corpus.&lt;/li&gt;
&lt;li&gt;Check the top words, add it to the final keyword list. Repeat this process.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Finally, we can use the keywords to classify the text and get the train data. &lt;/p&gt;
&lt;h4&gt;Classification by &lt;code&gt;doc2vec&lt;/code&gt; and Label Spreading&lt;/h4&gt;
&lt;p&gt;Keyword-based classification sometimes produces the wrong result, as it can't using the symantic information in the text. Fortunately, Google has open sourced &lt;code&gt;word2vec&lt;/code&gt;, which can be used to produce semantically meaningful word embeddings. Furthermore, sentences can also be converted to vectors by using &lt;code&gt;doc2vec&lt;/code&gt;. Sentences which has closed meaning also have short vector distance.&lt;/p&gt;
&lt;p&gt;So the problem is how to classify these vectors.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Using corpus to train the &lt;code&gt;doc2vec&lt;/code&gt; model.&lt;/li&gt;
&lt;li&gt;Using &lt;code&gt;doc2vec&lt;/code&gt; model to convert sentence into vector.&lt;/li&gt;
&lt;li&gt;Using label spreading algorithm to train a classify model to classify the vectors.&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;</description><category>doc2vec</category><category>mathjax</category><category>NLP</category><category>text classification</category><guid>https://bebound.github.io/posts/semi-supervised-text-classification-using-doc2vec-and-label-spreading/</guid><pubDate>Sun, 10 Sep 2017 14:18:15 GMT</pubDate></item><item><title>Parameters in dov2vec</title><link>https://bebound.github.io/posts/parameters-in-dov2vec/</link><dc:creator>Kurt Lei</dc:creator><description>&lt;div&gt;&lt;p&gt;Here are some parameter in &lt;code&gt;gensim&lt;/code&gt;'s &lt;code&gt;doc2vec&lt;/code&gt; class.&lt;/p&gt;
&lt;h4&gt;window&lt;/h4&gt;
&lt;p&gt;window is the maximum distance between the predicted word and context words used for prediction within a document. It will look behind and ahead.&lt;/p&gt;
&lt;p&gt;In &lt;code&gt;skip-gram&lt;/code&gt; model, if the window size is 2, the training samples will be this:(the blue word is the input word)&lt;/p&gt;
&lt;p&gt;&lt;img alt="window" src="https://bebound.github.io/images/doc2vec_window.png"&gt;&lt;/p&gt;
&lt;h4&gt;min_count&lt;/h4&gt;
&lt;p&gt;If the word appears less than this value, it will be skipped&lt;/p&gt;
&lt;h4&gt;sample&lt;/h4&gt;
&lt;p&gt;High frequency word like &lt;code&gt;the&lt;/code&gt; is useless for training. &lt;code&gt;sample&lt;/code&gt; is a threshold for deleting these higher-frequency words. The probability of keeping the word $w_i$ is:&lt;/p&gt;
&lt;p&gt;$$P(w_i) = (\sqrt{\frac{z(\omega_i)}{s}} + 1) \cdot \frac{s}{z(\omega_i)}$$&lt;/p&gt;
&lt;p&gt;where $z(w_i)$ is the frequency of the word and $s$ is the sample rate.&lt;/p&gt;
&lt;p&gt;This is the plot when &lt;code&gt;sample&lt;/code&gt; is 1e-3.&lt;/p&gt;
&lt;p&gt;&lt;img alt="negative-sample" src="https://bebound.github.io/images/doc2vec_negative_sample.png"&gt;&lt;/p&gt;
&lt;h4&gt;negative&lt;/h4&gt;
&lt;p&gt;Usually, when training a neural network, for each training sample, all of the weights in the neural network need to be tweaked. For example, if the word pair is ('fox', 'quick'), then only the word quick's neurons should output 1, and all of the other word neurons should output 0.&lt;/p&gt;
&lt;p&gt;But it would takes a lot of time to do this when we have billions of training samples. So, instead of update all of the weight, we random choose a small number of "negative" words (default value is 5) to update the weight.(Update their wight to output 0).&lt;/p&gt;
&lt;p&gt;So when dealing with word pair ('fox','quick'), we update quick's weight to output 1, and other 5 random words' wight to output 1.&lt;/p&gt;
&lt;p&gt;The probability of selecting word $\omega_i$ is $P(\omega_i)$:&lt;/p&gt;
&lt;p&gt;$$P(\omega_i) = \frac{  {f(\omega_i)}^{3/4}  }{\sum_{j=0}^{n}\left(  {f(\omega_j)}^{3/4} \right) }$$&lt;/p&gt;
&lt;p&gt;$f(\omega_j)$ is the frequency of word $\omega_j$.&lt;/p&gt;
&lt;p&gt;Ref:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://mccormickml.com/2016/04/19/word2vec-tutorial-the-skip-gram-model/"&gt;Word2Vec Tutorial - The Skip-Gram Model&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://mccormickml.com/2017/01/11/word2vec-tutorial-part-2-negative-sampling/"&gt;Word2Vec Tutorial Part 2 - Negative Sampling&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</description><category>doc2vec</category><category>mathjax</category><guid>https://bebound.github.io/posts/parameters-in-dov2vec/</guid><pubDate>Wed, 02 Aug 2017 16:02:17 GMT</pubDate></item><item><title>Brief Introduction of Label Propagation Algorithm</title><link>https://bebound.github.io/posts/brief-introduction-of-label-propagation-algorithm/</link><dc:creator>Kurt Lei</dc:creator><description>&lt;div&gt;&lt;p&gt;As I said before, I'm working on a text classification project. I use &lt;code&gt;doc2vec&lt;/code&gt; to convert text into vectors, then I use LPA to classify the vectors.&lt;/p&gt;
&lt;p&gt;LPA is a simple, effective semi-supervised algotithm. It can use the density of unlabeled data to find a hyperplane to split the data.&lt;/p&gt;
&lt;p&gt;Here are the main stop of the algorithm:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Let $ (x_1,y1)...(x_l,y_l)$ be labeled data, $Y_L = {y_1...y_l} $ are the class labels. Let $(x_{l+1},y_{l+u})$ be unlabeled data where $Y_U = {y_{l+1}...y_{l+u}}$ are unobserved, useally $l \ll u$. Let $X={x_1...x_{l+u}}$ where $x_i\in R^D$. The problem is to estimate $Y_U$ for $X$ and $Y_L$.&lt;/li&gt;
&lt;li&gt;Calculate the similarity of the data points. The most simple metric is Euclidean distance. Use a parameter $\sigma$ to cotrol the weights.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;$$w_{ij}= exp(-\frac{d^2_{ij}}{\sigma^2})=exp(-\frac{\sum^D_{d=1}{(x^d_i-x^d_j})^2}{\sigma^2})$$&lt;/p&gt;
&lt;p&gt;Larger weight allow labels to travel through easier.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Define a $(l+u)*(l+u)$ probabilistic transition matrix $T$&lt;/li&gt;
&lt;/ol&gt;
&lt;div&gt;

$$T_{ij}=P(j \rightarrow i)=\frac{w_{ij}}{\sum^{l+u}_{k=1}w_{kj}}$$

&lt;/div&gt;

&lt;p&gt;$T_{ij}$ is the probability to jump from node $j$ to $i$. If there are $C$ classes, we can define a $(l+u)*C$ label matrix $Y$, to represent the probability of a label belong to class $c$. The initialiation of unlabeled data points is not important.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Propagate $Y \leftarrow TY$&lt;/li&gt;
&lt;li&gt;Row-normalize Y.&lt;/li&gt;
&lt;li&gt;Reset labeled data's Y. Repeat 3 until Y converges.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;In short, let the nearest label has larger weight, then calculate each label's new label, reset labeled data's label, repeat.&lt;/p&gt;
&lt;p&gt;&lt;img alt="label spreading" src="https://bebound.github.io/images/label_spreading.png"&gt;&lt;/p&gt;
&lt;p&gt;Ref:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://mlg.eng.cam.ac.uk/zoubin/papers/CMU-CALD-02-107.pdf"&gt;Learning from Labeled and Unlabeled Data with Label Propagation&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://blog.csdn.net/zouxy09/article/details/49105265"&gt;标签传播算法（Label Propagation）及Python实现&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;</description><category>mathjax</category><guid>https://bebound.github.io/posts/brief-introduction-of-label-propagation-algorithm/</guid><pubDate>Sun, 16 Jul 2017 15:46:04 GMT</pubDate></item></channel></rss>